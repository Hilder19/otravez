def reconnect_to_mt5():
    """
    Intenta reconectar a MT5 en caso de desconexión.
    """
    mt5.shutdown()
    time.sleep(2)  # Espera corta para reconexión rápida
    if not mt5.initialize():
        print("Error al reconectar a MT5.")
        return False
    return True

def adjust_sl_tp_to_broker_limits(final_sl, new_tp, current_price, stop_level, symbol_info):
    """
    Ajusta SL y TP para cumplir con las restricciones de distancia mínima del broker.
    """
    digits = symbol_info.digits

    # Ajustar SL según restricciones del broker
    if abs(current_price - final_sl) < stop_level:
        final_sl = (current_price - stop_level if final_sl < current_price else current_price + stop_level)
        final_sl = round(final_sl, digits)

    # Ajustar TP según restricciones del broker
    if abs(new_tp - current_price) < stop_level:
        new_tp = (current_price + stop_level if new_tp > current_price else current_price - stop_level)
        new_tp = round(new_tp, digits)

    return final_sl, new_tp





# Archivo: scalping_close_positions.py
import MetaTrader5 as mt5

# Archivo: scalping_close_positions.py
import MetaTrader5 as mt5
import time

def scalping_close_positions(symbol, tp_percentage=0.05, sl_percentage=0.05, verbose=False):
    """
    Maneja operaciones de scalping cerrando posiciones basadas en niveles internos de TP y SL.
    """
    # Inicializar MT5
    if not mt5.initialize():
        print("Error: MetaTrader 5 no pudo inicializarse.")
        return

    # Comprobar conexión a la cuenta
    account_info = mt5.account_info()
    if not account_info or account_info.login == 0:
        print("Error: No se pudo conectar a la cuenta de MetaTrader 5.")
        mt5.shutdown()
        return
    if verbose:
        print(f"Conexión exitosa a MT5. Balance: {account_info.balance}, Equity: {account_info.equity}")

    # Intentar obtener posiciones abiertas para el símbolo dado
    positions = mt5.positions_get(symbol=symbol)
    if positions is None:
        print("Error al obtener posiciones abiertas. Intentando reconectar...")
        mt5.shutdown()
        time.sleep(2)  # Esperar antes de intentar reconectar
        if not mt5.initialize():
            print("Error: No se pudo reconectar a MetaTrader 5.")
            return
        positions = mt5.positions_get(symbol=symbol)
        if positions is None:
            print("Error persistente al obtener posiciones. Finalizando ejecución.")
            mt5.shutdown()
            return
    if len(positions) == 0:
        if verbose:
            print(f"No hay posiciones abiertas para {symbol}.")
        mt5.shutdown()
        return

    # Obtener información del símbolo
    symbol_info = mt5.symbol_info(symbol)
    if not symbol_info:
        print(f"Error: No se pudo obtener información del símbolo {symbol}.")
        mt5.shutdown()
        return

    # Validar stop_level mínimo permitido por el broker
    stop_level = symbol_info.trade_stops_level * symbol_info.point
    if verbose:
        print(f"Niveles mínimos permitidos por el broker para {symbol}: {stop_level}")

    for pos in positions:
        tick_info = mt5.symbol_info_tick(symbol)
        if not tick_info or tick_info.ask <= 0 or tick_info.bid <= 0:
            if verbose:
                print(f"Error: Información de precios inválida para {symbol}.")
            continue

        # Determinar el precio actual
        current_price = tick_info.ask if pos.type == mt5.ORDER_TYPE_BUY else tick_info.bid

        # Calcular niveles internos de TP y SL
        target_tp = (
            current_price * (1 + tp_percentage / 100) if pos.type == mt5.ORDER_TYPE_BUY
            else current_price * (1 - tp_percentage / 100)
        )
        target_sl = (
            current_price * (1 - sl_percentage / 100) if pos.type == mt5.ORDER_TYPE_BUY
            else current_price * (1 + sl_percentage / 100)
        )

        # Comprobar si se alcanzó el TP o SL interno
        if (pos.type == mt5.ORDER_TYPE_BUY and (current_price >= target_tp or current_price <= target_sl)) or \
           (pos.type == mt5.ORDER_TYPE_SELL and (current_price <= target_tp or current_price >= target_sl)):
            # Crear solicitud para cerrar la posición
            close_request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": pos.volume,
                "type": mt5.ORDER_TYPE_SELL if pos.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY,
                "price": current_price,
                "deviation": 2,
                "magic": pos.magic,
                "comment": "Cierre por scalping",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_IOC,
            }
            result = mt5.order_send(close_request)
            if result.retcode == mt5.TRADE_RETCODE_DONE:
                print(f"Posición cerrada correctamente: Ticket {pos.ticket}")
            else:
                print(f"Error al cerrar la posición {pos.ticket}: {result.retcode}")
        else:
            if verbose:
                print(f"Precio actual: {current_price}, TP Interno: {target_tp}, SL Interno: {target_sl}")

    # Cerrar conexión con MT5
    mt5.shutdown()
