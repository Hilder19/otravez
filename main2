import logging
import time
import MetaTrader5 as mt5
import pandas as pd
import MetaTrader5 as mt5
import pandas as pd
import numpy as np
from credenciales import*
from exness import*
from porcentaje_capital import*
from tipo_de_operacion import*
from ganacias_perdidas import*



def cerrar_conexion(sig, frame):
    """Manejador de la señal Ctrl + C para cerrar la conexión correctamente."""
    print("\nCerrando conexión con MT5...")
    mt5.shutdown()  # Cerrar MT5 de manera segura
    print("Conexión cerrada.")
    exit(0)  # Salir del programa

# Registrar el manejador de la señal Ctrl + C
signal.signal(signal.SIGINT, cerrar_conexion)



def connect_to_mt5():
    """Solicita credenciales al usuario y establece conexión con MetaTrader 5."""
    try:
        cuenta = int(input("Introduce tu número de cuenta: "))
        servidor = input("Introduce el nombre del servidor: ")
        contraseña = getpass.getpass("Introduce tu contraseña: ")  # Ocultar la contraseña
    except ValueError:
        print("Error: El número de cuenta debe ser un número entero.")
        return False

    # Inicializar MT5
    if not mt5.initialize():
        print("Error al inicializar MT5:", mt5.last_error())
        return False

    # Iniciar sesión
    if not mt5.login(cuenta, password=contraseña, server=servidor):
        print("Error al iniciar sesión:", mt5.last_error())
        mt5.shutdown()
        return False

    print("Conexión exitosa a MT5.")
    return True


def fetch_market_data(symbol, timeframe, limit):
    """Descarga datos de mercado desde MT5."""
    rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, limit)
    if rates is None:
        print(f"Error al obtener datos para {symbol}: {mt5.last_error()}")
        return None

    df = pd.DataFrame(rates)
    df['time'] = pd.to_datetime(df['time'], unit='s')
    return df

def calculate_indicators(df):
    """Calcula indicadores técnicos como MACD, RSI y ADX utilizando pandas."""

    # Calculando MACD
    df['ema_fast'] = df['close'].ewm(span=12, adjust=False).mean()
    df['ema_slow'] = df['close'].ewm(span=26, adjust=False).mean()
    df['macd'] = df['ema_fast'] - df['ema_slow']
    df['signal'] = df['macd'].ewm(span=9, adjust=False).mean()

    # Calculando RSI
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).fillna(0)
    loss = (-delta.where(delta < 0, 0)).fillna(0)
    avg_gain = gain.rolling(window=14, min_periods=1).mean()
    avg_loss = loss.rolling(window=14, min_periods=1).mean()
    rs = avg_gain / avg_loss
    df['rsi'] = 100 - (100 / (1 + rs))

    # Calculando ADX
    df['high_low'] = df['high'] - df['low']
    df['high_close'] = abs(df['high'] - df['close'].shift())
    df['low_close'] = abs(df['low'] - df['close'].shift())
    df['tr'] = df[['high_low', 'high_close', 'low_close']].max(axis=1)
    df['atr'] = df['tr'].rolling(window=14).mean()

    df['+dm'] = (df['high'].diff() > df['high'].diff().shift(-1)).astype(float) * df['high'].diff()
    df['-dm'] = (df['low'].diff() > df['low'].diff().shift(-1)).astype(float) * df['low'].diff()
    df['+dm'] = df['+dm'].where(df['+dm'] > 0, 0)
    df['-dm'] = df['-dm'].where(df['-dm'] > 0, 0)
    
    df['+di'] = 100 * (df['+dm'].rolling(window=14).sum() / df['atr'])
    df['-di'] = 100 * (df['-dm'].rolling(window=14).sum() / df['atr'])
    
    df['adx'] = 100 * (df['+di'] - df['-di']).abs() / (df['+di'] + df['-di'])
    
    return df

def generate_signal(row):
    """Genera señales de compra o venta basadas en indicadores."""
    if row['macd'] > row['signal'] and row['rsi'] < 70 and row['adx'] > 25:
        return 'buy'
    elif row['macd'] < row['signal'] and row['rsi'] > 30 and row['adx'] > 25:
        return 'sell'
    return 'hold'

import time  # Para controlar el intervalo de tiempo entre iteraciones

def show_trade_profit(ticket):
    """Muestra las ganancias o pérdidas de la operación recién ejecutada."""
    # Obtener información de la operación por su ticket
    order = mt5.order_get(ticket)
    if order is None:
        print("Error al obtener información de la operación.")
        return
    
    # Mostrar la ganancia o pérdida de la operación
    profit = order.profit  # La ganancia o pérdida de la operación
    print(f"Ganancia/Pérdida de la operación {ticket}: {profit}")

def execute_trade(signal, symbol, lot_size):
    """Ejecuta operaciones en MetaTrader 5 y muestra el resultado de la operación."""
    if signal == 'buy':
        order_type = mt5.ORDER_BUY
    elif signal == 'sell':
        order_type = mt5.ORDER_SELL
    else:
        return None

    # Crear el request para la orden
    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": lot_size,
        "type": order_type,
        "price": mt5.symbol_info_tick(symbol).ask if signal == 'buy' else mt5.symbol_info_tick(symbol).bid,
        "deviation": 20,
        "magic": 234000,
        "comment": "Robot de trading",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_IOC,
    }

    # Enviar la orden
    result = mt5.order_send(request)

    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"Error al ejecutar la operación: {result.retcode}")
        return None
    else:
        print(f"Operación {signal} ejecutada correctamente.")
        ticket = result.order  # Obtener el ticket de la operación
        show_trade_profit(ticket)  # Mostrar ganancias/pérdidas de la operación
        return ticket

def main():
    """Función principal del programa."""
    # Conectar a MT5
    if not connect_to_mt5():
        return

    # Configuración del robot
    symbol = "USDMXNm"  # Par de divisas
    timeframe = mt5.TIMEFRAME_H1  # Temporalidad
    lot_size = 0.1  # Tamaño del lote
    limit = 200  # Número de barras a descargar

    while True:
        # Obtener datos de mercado
        df = fetch_market_data(symbol, timeframe, limit)
        if df is None:
            print("Error al obtener los datos, reintentando...")
            time.sleep(60)  # Esperar 60 segundos antes de intentar de nuevo
            continue

        # Calcular indicadores
        df = calculate_indicators(df)

        # Generar señales
        df['signal'] = df.apply(generate_signal, axis=1)

        # Ejecutar la última señal
        latest_signal = df['signal'].iloc[-1]
        ticket = execute_trade(latest_signal, symbol, lot_size)

        # Si la operación fue exitosa, se muestra el resultado
        if ticket:
            print(f"Resultado de la operación {ticket}:")
            show_trade_profit(ticket)

        # Esperar un intervalo antes de repetir el proceso (por ejemplo, 60 segundos)
        time.sleep(60)  # Puedes ajustar este tiempo según la frecuencia de actualización que desees

# Cerrar conexión
mt5.shutdown()

if __name__ == "__main__":
    main()
