import logging
import time
import MetaTrader5 as mt5
import pandas as pd
import numpy as np
from credenciales import *
from exness import *
from porcentaje_capital import *
from tipo_de_operacion import *
from ganacias_perdidas import *
import getpass
import signal
from datetime import datetime, timedelta







# Configuración de logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')


def cerrar_conexion(sig, frame):
    """Manejador de la señal Ctrl + C para cerrar la conexión correctamente."""
    logging.info("\nCerrando conexión con MT5...")
    mt5.shutdown()  # Cerrar MT5 de manera segura
    logging.info("Conexión cerrada.")
    exit(0)  # Salir del programa


# Registrar el manejador de la señal Ctrl + C
signal.signal(signal.SIGINT, cerrar_conexion)


def connect_to_mt5():
    """Solicita credenciales al usuario y establece conexión con MetaTrader 5."""
    try:
        cuenta = int(input("Introduce tu número de cuenta: "))
        servidor = input("Introduce el nombre del servidor: ")
        contraseña = getpass.getpass("Introduce tu contraseña: ")  # Ocultar la contraseña
    except ValueError:
        logging.error("El número de cuenta debe ser un número entero.")
        return False

    # Inicializar MT5
    if not mt5.initialize():
        logging.error("Error al inicializar MT5: %s", mt5.last_error())
        return False

    # Iniciar sesión
    if not mt5.login(cuenta, password=contraseña, server=servidor):
        logging.error("Error al iniciar sesión: %s", mt5.last_error())
        mt5.shutdown()
        return False

    logging.info("Conexión exitosa a MT5.")
    return True






logging.basicConfig(level=logging.ERROR)

def get_account_equity():
    """
    Obtiene el balance y el margen libre de la cuenta.
    """
    # Obtiene la información de la cuenta
    account_info = mt5.account_info()
    if account_info is None:
        print("No se pudo obtener la información de la cuenta.")
        return None

    # Extrae el balance y el margen libre
    balance = account_info.balance
    free_margin = account_info.margin_free

    # Imprime los valores obtenidos en una sola línea
    print(f"Balance: {balance}, Margen libre: {free_margin}")

    # Retorna solo los valores como un diccionario sin mostrarlo
    return balance, free_margin







def calculate_risk_and_capital_distribution(symbols, free_margin):
    """
    Calcula el riesgo y distribuye el capital basado en el margen libre y el porcentaje definido por el usuario.
    
    Args:
        symbols (list): Lista de símbolos financieros.
        free_margin (float): Margen libre de la cuenta.
    
    Returns:
        dict: Un diccionario con la distribución de capital para cada símbolo.
    """
    if free_margin is None or free_margin <= 0:
        logging.error("El margen libre no es válido o es insuficiente.")
        return None

    try:
        # Solicitar al usuario el porcentaje del margen libre para asignar
        risk_percentage = float(input("Introduce el porcentaje del margen libre para asignar a los símbolos (0-100): "))
        if not 0 <= risk_percentage <= 100:
            logging.error("El porcentaje debe estar entre 0 y 100.")
            return None
    except ValueError:
        logging.error("Por favor, introduce un número válido.")
        return None

    # Calcular el capital por cada símbolo
    number_of_symbols = len(symbols)
    if number_of_symbols == 0:
        logging.error("La lista de símbolos está vacía.")
        return None

    capital_per_symbol = (free_margin * risk_percentage / 100) / number_of_symbols
    logging.info(f"El capital asignado a cada símbolo será: {capital_per_symbol:.2f}")

    # Crear un diccionario con el capital para cada símbolo
    capital_distribution = {symbol: capital_per_symbol for symbol in symbols}
    return capital_distribution













mt5.initialize()

# Configurar el símbolo (par de divisas), el intervalo y la cantidad de datos históricos
symbol = "BTCUSDm"
timeframe = mt5.TIMEFRAME_M1  # Gráfico de 1 minuto (M1)
num_bars = 200  # Últimos 200 datos de barras

# Variable global para almacenar la tendencia anterior
previous_trend = None

# Función para obtener los datos históricos
def get_data(symbol, timeframe, num_bars):
    rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, num_bars)
    if rates is None or len(rates) == 0:
        raise ValueError(f"No se pudieron obtener datos históricos para el símbolo {symbol}.")
    
    data = pd.DataFrame(rates)
    data['time'] = pd.to_datetime(data['time'], unit='s')
    return data

# Funciones para cálculos de indicadores
def calculate_ema(series, period):
    return series.ewm(span=period, adjust=False).mean()

def calculate_rsi(series, period):
    delta = series.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

def calculate_macd(series, fast_period, slow_period, signal_period):
    fast_ema = calculate_ema(series, fast_period)
    slow_ema = calculate_ema(series, slow_period)
    macd = fast_ema - slow_ema
    signal = calculate_ema(macd, signal_period)
    return macd, signal

def calculate_bbands(series, period, std_dev):
    sma = series.rolling(window=period).mean()
    std = series.rolling(window=period).std()
    upper_band = sma + (std_dev * std)
    lower_band = sma - (std_dev * std)
    return upper_band, sma, lower_band

# Detectar microtendencia
def detect_microtrend(data):
    # Calcular indicadores
    data['ema5'] = calculate_ema(data['close'], 5)
    data['ema13'] = calculate_ema(data['close'], 13)
    data['rsi'] = calculate_rsi(data['close'], 14)
    data['macd'], data['signal'] = calculate_macd(data['close'], 12, 26, 9)
    data['upper_band'], _, data['lower_band'] = calculate_bbands(data['close'], 20, 2)

    last_row = data.iloc[-1]

    # Registrar valores para diagnóstico
    print(f"Valores actuales: EMA5={last_row['ema5']:.2f}, EMA13={last_row['ema13']:.2f}, "
          f"RSI={last_row['rsi']:.2f}, MACD={last_row['macd']:.2f}, Signal={last_row['signal']:.2f}, "
          f"Close={last_row['close']:.2f}, UpperBand={last_row['upper_band']:.2f}, "
          f"LowerBand={last_row['lower_band']:.2f}")

    # Detectar microtendencia alcista
    if (last_row['ema5'] > last_row['ema13'] * 0.99 and  # Margen del 1% entre las EMAs
        last_row['rsi'] > 30 and  # Relajamos la condición de RSI
        last_row['macd'] > last_row['signal'] - 0.01 and  # Margen del 0.01 en MACD y Signal
        last_row['close'] > last_row['upper_band'] * 0.98):  # Margen del 2% en bandas
        return last_row, 'Alcista'

    # Detectar microtendencia bajista
    if (last_row['ema5'] < last_row['ema13'] * 1.01 and  # Margen del 1% entre las EMAs
        last_row['rsi'] < 70 and  # Relajamos la condición de RSI
        last_row['macd'] < last_row['signal'] + 0.01 and  # Margen del 0.01 en MACD y Signal
        last_row['close'] < last_row['lower_band'] * 1.02):  # Margen del 2% en bandas
        return last_row, 'Bajista'

    return last_row, 'Neutral'
# Ejecutar operaciones
def execute_trade(last_row, symbol, capital_assigned, risk_per_trade=0.5):
    # 0 para BUY, 1 para SELL
    if last_row['ema5'] > last_row['ema13']:
        order_type = 0  # BUY
    elif last_row['ema5'] < last_row['ema13']:
        order_type = 1  # SELL
    else:
        print("No se ejecutó ninguna operación. Las EMAs no indican una tendencia clara.")
        return None

    symbol_info = mt5.symbol_info(symbol)
    if not symbol_info:
        print(f"Error: Información no encontrada para el símbolo {symbol}.")
        return None

    price = last_row['close']
    if not price or price <= 0:
        print(f"Error: Precio inválido para el símbolo {symbol}.")
        return None

    contract_size = getattr(symbol_info, 'contract_size', 1)
    try:
        lot_size = (capital_assigned * (risk_per_trade / 100)) / (contract_size * price)
        lot_size = max(min(round(lot_size / symbol_info.volume_step) * symbol_info.volume_step, symbol_info.volume_max), symbol_info.volume_min)
    except (ZeroDivisionError, AttributeError) as e:
        print(f"Error al calcular el tamaño del lote: {e}")
        return None

    tp_percentage = 0.001 / 100
    tp_price = price * (1 + tp_percentage) if order_type == 0 else price * (1 - tp_percentage)

    requests = []
    for i in range(5):
        requests.append({
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": lot_size,
            "type": order_type,
            "price": price,
            "tp": tp_price,
            "deviation": 2,
            "magic": 234002,
            "comment": f"Scalping {i + 1}/5",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_IOC,
        })

    results = []
    for request in requests:
        result = mt5.order_send(request)
        if result.retcode == mt5.TRADE_RETCODE_DONE:
            print(f"Operación ejecutada correctamente. Ticket: {result.order}")
            results.append(result.order)
        else:
            print(f"Error al ejecutar la operación: {result.retcode}")

    return results if results else None

# Bucle principal dentro de una función
def main_loop():
    global previous_trend

    # Conectar a MetaTrader 5
    if not connect_to_mt5():
        logging.error("No se pudo conectar a MT5. Cerrando el programa.")
        return

    # Obtener balance y margen libre
    balance, free_margin = get_account_equity()
    if free_margin is None:
        logging.error("No se puede proceder sin margen libre.")
        return

    # Solicitar símbolos y distribuir capital
    symbols = input("Introduce los símbolos separados por comas (e.g., BTCUSDm, EURUSDm,GBPUSDm): ").split(',')
    capital_distribution = calculate_risk_and_capital_distribution(symbols, free_margin)
    if capital_distribution is None:
        logging.error("No se pudo calcular la distribución de capital.")
        return

    while True:
        try:
            data = get_data(symbol, timeframe, num_bars)
            last_row, trend = detect_microtrend(data)

            logging.info(f"Microtendencia actual en {symbol}: {trend}")
            if trend in ['Alcista', 'Bajista']:
                if trend != previous_trend:
                    execute_trade(last_row, symbol, capital_assigned=capital_distribution.get(symbol, 1000))
                    previous_trend = trend
                else:
                    logging.info("La tendencia actual ya ha sido procesada.")
            else:
                logging.info("No se detectó una señal clara. Esperando nueva oportunidad...")
            time.sleep(30)
        except Exception as e:
            logging.error(f"Error en el bucle principal: {e}")

# Llamar a la función principal
if __name__ == "__main__":
    main_loop()
