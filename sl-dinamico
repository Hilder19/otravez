import MetaTrader5 as mt5
import time

def execute_trade(latest_signal, symbol, capital_assigned, risk_per_trade=1.0, tp_percentage=1.5, sl_percentage=1.0, trailing_distance=0.5):
    """
    Ejecuta operaciones en MetaTrader 5 con SL y TP dinámicos.
    Si se cierra una posición por SL/TP, se abre una nueva operación automáticamente.
    """

    # Validar inicialización de MetaTrader 5
    if not mt5.initialize():
        print(f"Error inicializando MetaTrader 5: {mt5.last_error()}")
        return None

    # Obtener información del símbolo
    symbol_info = mt5.symbol_info(symbol)
    if not symbol_info:
        print(f"Error: Información del símbolo {symbol} no encontrada.")
        return None

    # Manejar distancia mínima de SL/TP
    stop_level = getattr(symbol_info, 'stop_level', 0)
    point = getattr(symbol_info, 'point', 0.0001)
    min_stop_distance = stop_level * point

    while True:
        positions = mt5.positions_get(symbol=symbol)

        # Si no hay posiciones abiertas, abre una nueva operación
        if not positions:
            print(f"No hay posiciones abiertas para {symbol}. Intentando abrir una nueva operación...")

            # Determinar tipo de orden
            order_type = 0 if latest_signal == 'buy' else 1 if latest_signal == 'sell' else None
            if order_type is None:
                print("Error: Señal inválida.")
                return None

            # Obtener precios actuales
            tick = mt5.symbol_info_tick(symbol)
            if not tick:
                print(f"Error: No se pudo obtener información del precio para {symbol}.")
                return None

            price = tick.ask if latest_signal == 'buy' else tick.bid

            # Calcular tamaño del lote
            lot_size = (capital_assigned * (risk_per_trade / 100)) / price
            lot_size = round(lot_size / symbol_info.volume_step) * symbol_info.volume_step
            lot_size = max(symbol_info.volume_min, min(lot_size, symbol_info.volume_max))

            # Calcular SL y TP iniciales
            sl_price = price * (1 - sl_percentage / 100) if latest_signal == 'buy' else price * (1 + sl_percentage / 100)
            tp_price = price * (1 + tp_percentage / 100) if latest_signal == 'buy' else price * (1 - tp_percentage / 100)

            # Validar distancia mínima de SL/TP
            sl_price = max(sl_price, price - min_stop_distance) if latest_signal == 'buy' else min(sl_price, price + min_stop_distance)
            tp_price = min(tp_price, price + min_stop_distance) if latest_signal == 'buy' else max(tp_price, price - min_stop_distance)

            # Crear solicitud de operación
            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": lot_size,
                "type": order_type,
                "price": price,
                "sl": round(sl_price, symbol_info.digits),
                "tp": round(tp_price, symbol_info.digits),
                "deviation": 20,
                "magic": 234000,
                "comment": "Robot de trading",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_IOC,
            }

            # Enviar la solicitud
            result = mt5.order_send(request)
            if result.retcode == mt5.TRADE_RETCODE_DONE:
                print(f"Operación ejecutada correctamente: \n"
                      f"  Tipo: {'Compra' if latest_signal == 'buy' else 'Venta'}\n"
                      f"  Símbolo: {symbol}\n"
                      f"  Volumen: {lot_size}\n"
                      f"  Precio: {price}\n"
                      f"  SL: {request['sl']}\n"
                      f"  TP: {request['tp']}\n"
                      f"  Ticket: {result.order}")
            else:
                print(f"Error ejecutando operación ({symbol}): {result.retcode}, {result.comment}")
                return None

        # Si hay posiciones abiertas, ajusta SL/TP dinámicos
        else:
            for pos in positions:
                current_price = mt5.symbol_info_tick(symbol).ask if pos.type == 0 else mt5.symbol_info_tick(symbol).bid

                # Calcular nuevos SL y TP
                new_sl = max(current_price - trailing_distance * point, current_price - min_stop_distance) if pos.type == 0 else \
                         min(current_price + trailing_distance * point, current_price + min_stop_distance)

                new_tp = min(current_price + tp_percentage * point, current_price + min_stop_distance) if pos.type == 0 else \
                         max(current_price - tp_percentage * point, current_price - min_stop_distance)

                # Redondear valores
                new_sl = round(new_sl, symbol_info.digits)
                new_tp = round(new_tp, symbol_info.digits)

                # Verificar si SL/TP han cambiado
                if new_sl != pos.sl or new_tp != pos.tp:
                    modify_request = {
                        "action": mt5.TRADE_ACTION_SLTP,
                        "symbol": symbol,
                        "position": pos.ticket,
                        "sl": new_sl,
                        "tp": new_tp,
                    }
                    modify_result = mt5.order_send(modify_request)
                    if modify_result.retcode == mt5.TRADE_RETCODE_DONE:
                        print(f"SL/TP ajustados: \n"
                              f"  Nuevo SL: {new_sl}\n"
                              f"  Nuevo TP: {new_tp}")
                    else:
                        print(f"Error ajustando SL/TP: Retcode: {modify_result.retcode}, Mensaje: {modify_result.comment}")

                # Verificar si la posición sigue activa
                updated_positions = mt5.positions_get(symbol=symbol)
                if not updated_positions:
                    print(f"Posición cerrada ({symbol}). SL o TP alcanzado.")
                    # Forzar apertura de una nueva operación inmediatamente
                    break

        # Pausa antes de la próxima iteración
        time.sleep(1)
