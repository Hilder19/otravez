import MetaTrader5 as mt5
import time

def execute_trade(latest_signal, symbol, capital_assigned, risk_per_trade=1.0, tp_percentage=1.5, sl_percentage=1.0, trailing_distance=0.5):
    """
    Ejecuta operaciones en MetaTrader 5 con SL y TP dinámicos.
    Si se cierra una posición por SL/TP, se abre una nueva operación automáticamente.
    """

    if not mt5.initialize():
        print(f"Error inicializando MetaTrader 5: {mt5.last_error()}")
        return None

    symbol_info = mt5.symbol_info(symbol)
    if not symbol_info:
        print(f"Error: Información del símbolo {symbol} no encontrada.")
        return None

    stop_level = symbol_info.stop_level
    point = symbol_info.point

    while True:
        positions = mt5.positions_get(symbol=symbol)

        # Si no hay posiciones abiertas, abre una nueva operación
        if not positions:
            print(f"No hay posiciones abiertas para {symbol}. Intentando abrir una nueva operación...")

            order_type = 0 if latest_signal == 'buy' else 1 if latest_signal == 'sell' else None
            if order_type is None:
                print("Error: Señal inválida.")
                return None

            tick = mt5.symbol_info_tick(symbol)
            if not tick:
                print(f"Error: No se pudo obtener información del precio para {symbol}.")
                return None

            price = tick.ask if latest_signal == 'buy' else tick.bid

            lot_size = (capital_assigned * (risk_per_trade / 100)) / price
            lot_size = round(lot_size / symbol_info.volume_step) * symbol_info.volume_step
            lot_size = max(symbol_info.volume_min, min(lot_size, symbol_info.volume_max))

            sl_price = price - sl_percentage * point if latest_signal == 'buy' else price + sl_percentage * point
            tp_price = price + tp_percentage * point if latest_signal == 'buy' else price - tp_percentage * point

            # Validar distancias mínimas de SL/TP
            if latest_signal == 'buy':
                sl_price = max(sl_price, price - stop_level * point)
                tp_price = max(tp_price, price + stop_level * point)
            else:
                sl_price = min(sl_price, price + stop_level * point)
                tp_price = min(tp_price, price - stop_level * point)

            # Redondear valores
            sl_price = round(sl_price, symbol_info.digits)
            tp_price = round(tp_price, symbol_info.digits)

            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": lot_size,
                "type": order_type,
                "price": price,
                "sl": sl_price,
                "tp": tp_price,
                "deviation": 20,
                "magic": 234000,
                "comment": "Robot de trading",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_IOC,
            }

            result = mt5.order_send(request)
            if result.retcode == mt5.TRADE_RETCODE_DONE:
                print(f"Operación ejecutada correctamente: \n"
                      f"  Tipo: {'Compra' if latest_signal == 'buy' else 'Venta'}\n"
                      f"  Símbolo: {symbol}\n"
                      f"  Volumen: {lot_size}\n"
                      f"  Precio: {price}\n"
                      f"  SL: {sl_price}\n"
                      f"  TP: {tp_price}\n"
                      f"  Ticket: {result.order}")
            else:
                print(f"Error ejecutando operación ({symbol}): {result.retcode}, {result.comment}")
                return None
        else:
            # Verificar si las posiciones existentes han alcanzado SL o TP
            for pos in positions:
                tick = mt5.symbol_info_tick(symbol)
                if not tick:
                    print(f"Error: No se pudo obtener información del precio para {symbol}.")
                    return None

                current_price = tick.ask if pos.type == 0 else tick.bid

                # Si SL o TP alcanzados, cierra la posición
                if (pos.type == 0 and current_price <= pos.sl) or (pos.type == 1 and current_price >= pos.tp):
                    print(f"Posición cerrada ({symbol}). SL o TP alcanzado.")
                    close_request = {
                        "action": mt5.TRADE_ACTION_DEAL,
                        "symbol": symbol,
                        "volume": pos.volume,
                        "type": 1 if pos.type == 0 else 0,  # Cerrar con operación opuesta
                        "price": current_price,
                        "deviation": 20,
                        "magic": pos.magic,
                        "comment": "Cerrar posición",
                    }
                    close_result = mt5.order_send(close_request)
                    if close_result.retcode == mt5.TRADE_RETCODE_DONE:
                        print(f"Posición cerrada con éxito: {pos.ticket}")
                        latest_signal = 'buy' if pos.type == 1 else 'sell'
                        break  # Salir para abrir una nueva operación
                    else:
                        print(f"Error cerrando posición: Retcode: {close_result.retcode}, Mensaje: {close_result.comment}")

        time.sleep(1)
