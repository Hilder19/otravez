import MetaTrader5 as mt5
import time

def reconnect_to_mt5():
    """
    Intenta reconectar a MT5 en caso de desconexión.
    """
    mt5.shutdown()
    time.sleep(5)
    if not mt5.initialize():
        print("Error al reconectar a MT5.")
        return False
    return True

def adjust_sl_tp_to_broker_limits(final_sl, new_tp, current_price, stop_level, symbol_info):
    """
    Ajusta SL y TP para cumplir con las restricciones de distancia mínima del broker.
    """
    digits = symbol_info.digits

    # Asegurar que SL cumple con la distancia mínima
    if abs(current_price - final_sl) < stop_level:
        if final_sl < current_price:  # Para Buy
            final_sl = current_price - stop_level
        else:  # Para Sell
            final_sl = current_price + stop_level
        final_sl = round(final_sl, digits)

    # Asegurar que TP cumple con la distancia mínima
    if abs(new_tp - current_price) < stop_level:
        if new_tp > current_price:  # Para Buy
            new_tp = current_price + stop_level
        else:  # Para Sell
            new_tp = current_price - stop_level
        new_tp = round(new_tp, digits)

    return final_sl, new_tp

def close_open_positions(symbol, tp_percentage=1.5, sl_percentage=1.0, trailing_distance=0.5, verbose=False):
    """
    Modifica SL y TP dinámicamente o cierra posiciones abiertas para un símbolo.
    Ajusta automáticamente el trailing_distance al mínimo permitido por el broker si es demasiado pequeño.
    """
    if not mt5.initialize():
        print("MetaTrader 5 no pudo inicializarse.")
        return

    while True:
        # Verificar la conexión
        terminal_info = mt5.terminal_info()
        if not terminal_info or not terminal_info.connected:
            if not reconnect_to_mt5():
                print("No se pudo reconectar a MT5.")
                return

        positions = mt5.positions_get(symbol=symbol)
        if not positions:
            if verbose:
                print(f"No hay posiciones abiertas para {symbol}.")
            break

        symbol_info = mt5.symbol_info(symbol)
        if not symbol_info:
            print(f"Error: No se pudo obtener información del símbolo {symbol}.")
            return

        # Obtener la distancia mínima permitida por el broker
        stop_level = symbol_info.trade_stops_level * symbol_info.point
        successful_updates = 0
        failed_updates = 0

        for pos in positions:
            # Obtener el precio actual
            tick_info = mt5.symbol_info_tick(symbol)
            if not tick_info or tick_info.ask <= 0 or tick_info.bid <= 0:
                if verbose:
                    print(f"Error: Información de precios inválida para {symbol}.")
                continue

            current_price = tick_info.ask if pos.type == mt5.ORDER_TYPE_BUY else tick_info.bid

            # Calcular el SL estático basado en sl_percentage
            sl_static = (
                current_price * (1 - sl_percentage / 100) if pos.type == mt5.ORDER_TYPE_BUY
                else current_price * (1 + sl_percentage / 100)
            )

            # Ajustar la distancia del trailing stop al mínimo permitido
            adjusted_trailing_distance = max(trailing_distance / 100 * current_price, stop_level)
            trailing_sl = (
                max(pos.price_open, current_price) - adjusted_trailing_distance if pos.type == mt5.ORDER_TYPE_BUY
                else min(pos.price_open, current_price) + adjusted_trailing_distance
            )

            # Seleccionar el SL final
            final_sl = (
                max(sl_static, trailing_sl) if pos.type == mt5.ORDER_TYPE_BUY
                else min(sl_static, trailing_sl)
            )

            # Calcular el nuevo Take Profit (TP)
            new_tp = (
                current_price * (1 + tp_percentage / 100) if pos.type == mt5.ORDER_TYPE_BUY
                else current_price * (1 - tp_percentage / 100)
            )

            # Redondear SL y TP a la cantidad de dígitos permitidos por el símbolo
            final_sl = round(final_sl, symbol_info.digits)
            new_tp = round(new_tp, symbol_info.digits)

            # Ajustar SL/TP para cumplir con las restricciones del broker
            final_sl, new_tp = adjust_sl_tp_to_broker_limits(final_sl, new_tp, current_price, stop_level, symbol_info)

            # Crear la solicitud de modificación
            modify_request = {
                "action": mt5.TRADE_ACTION_SLTP,
                "symbol": symbol,
                "position": pos.ticket,
                "sl": final_sl,
                "tp": new_tp,
            }

            # Enviar la solicitud de modificación
            modify_result = mt5.order_send(modify_request)
            if modify_result.retcode == mt5.TRADE_RETCODE_DONE:
                successful_updates += 1
            else:
                failed_updates += 1
                if verbose:
                    print(f"Error modificando SL/TP para posición {pos.ticket}: {modify_result.retcode}")

            time.sleep(0.2)  # Reducir la saturación de solicitudes

        # Mostrar un resumen de las modificaciones realizadas
        if verbose:
            print(f"{successful_updates} SL/TP modificados correctamente, {failed_updates} fallidos para {symbol}.")

    mt5.shutdown()
